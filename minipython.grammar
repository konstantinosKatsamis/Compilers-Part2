/*Κούρος Γεώργιος 3190095
  Κατσάμης Κωνσταντίνος 3190237
  Ανδρινόπουλος Κωνσταντίνος 3190009
*/

Package minipython;

Helpers
	digit = ['0' .. '9'];
	letter = ['a' .. 'z']|['A' .. 'Z']; 
	cr = 13; 
	lf = 10;
	all = [0..127]; 
	eol = lf | cr | cr lf;
	not_eol = [all - [cr + lf]];
	d_quote = '"';
	s_quote = ''';

Tokens
	tab = 9;
	plus = '+';
    plus_plus = '++';
    minus_minus = '--';
	minus = '-';
	mult = '*';
	mult_mult = '**';
	div = '/';
    mod = '%';
	eq = '=';
    self_minus = '-=';
    self_divide = '/=';
    type = 'type';
	def = 'def';
	l_par = '(';
	r_par = ')';
	l_br = '[';
	r_br = ']';
	comma=',';
	if = 'if';
	while = 'while';
    for = 'for';
    in = 'in';
	print = 'print';
	return = 'return';
	less = '<';
	great = '>';
    great_eq = '>=';
    less_eq = '<=';
    eq_eq = '==';
    not_eq = '!=';
	true = 'true';
	semi = ':';
	false = 'false';
	blank = (' ' | lf | cr);
	line_comment = '#' not_eol* eol; 
    dot = '.';
	number = digit+ | (digit+ '.' digit+);
	string = '"'not_eol* '"';
    assert = 'assert';
    max = 'max';
    min = 'min';
    and = 'and';
    or = 'or';
	none = 'None';
    not = 'not';
	integer_literal = digit+ | (digit+ '.' digit+);
	identifier = letter (letter | digit | '_')*;
	string_literal = d_quote [not_eol - d_quote]* d_quote | s_quote [not_eol - s_quote]* s_quote;

Ignored Tokens
	blank, line_comment;

Productions

    goal = command*{-> New goal([command])};
	
	command = {func} function{-> New command.funct(function)} |
              {statement} statement{-> New command.statement(statement)};

	function = def identifier l_par argument? r_par semi statement {-> New function(identifier, argument, statement) };

    argument = identifier assign_value? comma_id_assign_value* {-> New argument(identifier, assign_value) };

    comma_id_assign_value = comma identifier assign_value?; /* TODO */
  
    assign_value = eq value; /* TODO */
  
    statement = {if}tab* if comparison semi statement {-> New statement.if(comparison, statement)} |
                {while}tab* while comparison semi statement {-> New statement.while(comparison, statement)} |
                {for}tab* for [id1]: identifier in [id2]: identifier semi statement {-> New statement.for(id1, id2, statement)} |
                {return}tab* return expression {-> New statement.return(expression)} |
                {print}tab* print expression comma_expression* {-> New stamenent.print()} | /* TODO */
				{eq}tab* identifier eq expression {-> New statement.eq(identifier, expression)} |
                {s_minus}tab* identifier self_minus expression {-> New statement.s_minus(identifier, expression)} |
				{minus_minus}tab* identifier minus_minus expression {-> New statement.minus_minus(identifier, expression)} |
                {self_divide}tab* identifier self_divide expression {-> New statement.self_divide(identifier, expression)} |
                {assign_list}tab* identifier l_br [ex1]: expression r_br eq [ex2]: expression {-> New stamenent.assign_list(identifier, ex1, ex2)} |
			    {assert}tab* assert expression comma_expression? {-> New statement.assert()} | /* TODO */
                {func_call}tab* function_call {-> New statement.fun_call(function_call)};
	
	expression = sum{-> New sum.expression};

	sum{->expression} = {sum} sum plus term{-> New expression.arithmetic(sum.expression, New binop.plus(plus), term.expression)} |
			{minus} sum minus term{-> New expression.arithmetic(sum.expression, New binop.minus(minus), term.expression)} |
			{plus_plus} expression plus_plus{-> New expression.arithmetic(sum.expression, New binop.plus_plus(plus_plus))} |
			{minus_minus} expression minus_minus{-> New expression.arithmetic(sum.expression, New binop.minus_minus(minus_minus))} |
			{term} term{-> term.expression};
	
	term{-> expression} = {mult} term mult power{-> New expression.arithmetic(term.expression, New binop.mult(mult), power.expression)} |
			{div} term div power{-> New expression.arithmetic(term.expression, New binop.div(div), power.expression)} |
			{modulo} term mod power{-> New expression.arithmetic(term.expression, New binop.modulo(mod), power.expression)} |
			{power} power{-> power.expression};
	
	power{-> expression} = {exp} power mult_mult subscription{-> New expression.arithmetic(power.expression, New binop.pow(mult_mult), subscription.expression)} |
			{subscription} subscription{-> subscription.expression};
	
	subscription = {subscription} identifier l_br expression r_br{New expression.subscription(identifier, expression)} |
			{func} func{-> func.expression};
	
	func{-> expression} = {type} type l_par identifier r_par |
	   {max} max l_par value comma_value+ r_par |
	   {min} min l_par value comma_value+ r_par |
	   {func} function_call |
	   {par} par;

	par = {par} l_par expression r_par |
	  	{something} something ;
	
	something = {value} value |
		{identifier} identifier;

	comparison = seperation;

	seperation = {or} seperation or conjuction |
			{and} conjuction;
	
	conjuction = {and} conjuction and refusal |
		 {not} refusal;

	refusal = {refusal} not clause |
			{clause} clause;

    clause = {great} [exp1]: expression great [exp2]: expression|
	     	 {less} [exp1]: expression less [exp2]: expression |
	   	     {less_eq} [exp1]: expression less_eq [exp2]: expression |
	    	 {great_eq} [exp1]: expression great_eq [exp2]: expression |
	    	 {not_eq} [exp1]: expression not_eq [exp2]: expression |
	     	 {eq} [exp1]: expression eq_eq [exp2]: expression |
	   	  	 {true} true |
			 {false} false;

	value = {fun_call} identifier dot function_call |
			{str_call} string_literal |
			{none} none |
			{num} number |
            {str} string;

    function_call = identifier l_par arglist? r_par;

    arglist = expression comma_expression*;

    comma_expression = comma expression;

	comma_value = comma value;

Abstract Syntax Tree
	goal = command*;

	command = {func} function | {statement} statement ;

	function = 

	argument = 

	comma_id_assign_value = 

	assign_value = 

	statement = 

	expression = {arithmetic} [e1]:expression binop [e2]:expression |
			/* TODO */
			;

	binop = {plus} plus |
            {minus} minus |
            {mult} mult |
            {div} div |
            {modulo} mode |
            {pow} mult_mult;

	sum =

	term =

	power =

	subscription =

	func =

	par =

	something =

	comparison =

	seperation =

	conjuction =

	refusal =

	clause =

	value =

	function_call =

	arglist =

	comma_expression =

	comma_value =