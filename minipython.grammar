/*Κούρος Γεώργιος 3190095
  Κατσάμης Κωνσταντίνος 3190237
  Ανδρινόπουλος Κωνσταντίνος 3190009
*/

Package minipython;

Helpers
	digit = ['0' .. '9'];
	letter = ['a' .. 'z']|['A' .. 'Z']; 
	cr = 13; 
	lf = 10;
	all = [0..127]; 
	eol = lf | cr | cr lf;
	not_eol = [all - [cr + lf]];
	d_quote = '"';
	s_quote = ''';

Tokens
	tab = 9;
	plus = '+';
    plus_plus = '++';
    minus_minus = '--';
	minus = '-';
	mult = '*';
	mult_mult = '**';
	div = '/';
    mod = '%';
	eq = '=';
    self_minus = '-=';
    self_divide = '/=';
    type = 'type';
	def = 'def';
	l_par = '(';
	r_par = ')';
	l_br = '[';
	r_br = ']';
	comma=',';
	if = 'if';
	while = 'while';
    for = 'for';
    in = 'in';
	print = 'print';
	return = 'return';
	less = '<';
	great = '>';
    great_eq = '>=';
    less_eq = '<=';
    eq_eq = '==';
    not_eq = '!=';
	true = 'true';
	semi = ':';
	false = 'false';
	blank = (' ' | lf | cr);
	line_comment = '#' not_eol* eol; 
    dot = '.';
	number = digit+ | (digit+ '.' digit+);
	string = '"'not_eol* '"';
    assert = 'assert';
    max = 'max';
    min = 'min';
    and = 'and';
    or = 'or';
	none = 'None';
    not = 'not';
	integer_literal = digit+ | (digit+ '.' digit+);
	identifier = letter (letter | digit | '_')*;
	string_literal = d_quote [not_eol - d_quote]* d_quote | s_quote [not_eol - s_quote]* s_quote;

Ignored Tokens
	blank, line_comment;

Productions

    goal = command*{-> New goal([command])};
	
	command = {func} function{-> New command.funct(function)} |
              {statement} statement{-> New command.statement(statement)};

	function = def identifier l_par argument? r_par semi statement {-> New function(identifier, argument, statement) };

    argument = identifier assign_value? comma_id_assign_value* {-> New argument(identifier, assign_value) };

    comma_id_assign_value = comma identifier assign_value?;
  
    assign_value = eq value;
  
    statement = {if}tab* if comparison semi statement
				{-> New statement.if(comparison, statement)} |
                {while}tab* while comparison semi statement
				{-> New statement.while(comparison, statement)}|
                {for}tab* for [id1]: identifier in [id2]: identifier semi statement
				{-> New statement.for(id1, id2, statement)}|
                {return}tab* return expression
				{-> New statement.return(expression)}|
                {print}tab* print expression comma_expression*
				{-> New stamenent.print()}|
				{eq}tab* identifier eq expression
				{-> New statement.eq(identifier, expression)}|
                {s_minus}tab* identifier self_minus expression
				{-> New statement.s_minus(identifier, expression) }|
				{minus_minus}tab* identifier minus_minus expression 
				{-> New statement.minus_minus(identifier, expression) }|
                {self_divide}tab* identifier self_divide expression 
				{-> New statement.self_divide(identifier, expression)}|
                {assign_list}tab* identifier l_br [ex1]: expression r_br eq [ex2]: expression
				{-> New stamenent.assign_list(identifier, ex1, ex2)}|
			    {assert}tab* assert expression comma_expression?
				{-> New statement.assert()}|
                {func_call}tab* function_call
				{-> New statement.fun_call(function_call)};
	
	expression = sum;

	sum = {sum} sum plus term |
			{minus} sum minus term |
			{plus_plus} expression plus_plus|
			{minus_minus} expression minus_minus|
			{term} term;
	
	term = {mult} term mult power |
			{div} term div power |
			{modulo} term mod power |
			{power} power;
	
	power = {exp} power mult_mult subscription |
			{subscription} subscription;
	
	subscription = {subscription} identifier l_br expression r_br |
			{func} func;
	
	func = {type} type l_par identifier r_par |
	   {max} max l_par value comma_value+ r_par |
	   {min} min l_par value comma_value+ r_par |
	   {func} function_call |
	   {par} par;

	par = {par} l_par expression r_par |
	  	{something} something ;
	
	something = {value} value |
		{identifier} identifier;

	comparison = seperation;

	seperation = {or} seperation or conjuction |
			{and} conjuction;
	
	conjuction = {and} conjuction and refusal |
		 {not} refusal;

	refusal = {refusal} not clause |
			{clause} clause;

    clause = {great} [exp1]: expression great [exp2]: expression|
	     	 {less} [exp1]: expression less [exp2]: expression |
	   	     {less_eq} [exp1]: expression less_eq [exp2]: expression |
	    	 {great_eq} [exp1]: expression great_eq [exp2]: expression |
	    	 {not_eq} [exp1]: expression not_eq [exp2]: expression |
	     	 {eq} [exp1]: expression eq_eq [exp2]: expression |
	   	  	 {true} true |
			 {false} false;

	/* sto bnf etsi ta zhtaei */
	value = {fun_call} identifier dot function_call |
			{str_call} string_literal |
			{none} none |
			{num} number |
            {str} string;

    function_call = identifier l_par arglist? r_par;

    arglist = expression comma_expression*;

    comma_expression = comma expression;

	comma_value = comma value;
